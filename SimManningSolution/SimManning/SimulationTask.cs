using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using SimManning.IO;

namespace SimManning
{
	/// <summary>
	/// A task to be simulated. Almost everything is represented as a task (of different <see cref="TaskType"/>),
	/// including rest, sleep, weather events, etc.
	/// </summary>
	public abstract partial class SimulationTask
	{
		readonly int id;

		public int Id
		{
			get { return this.id; }
		}

		string name;

		/// <summary>
		/// The name of the task.
		/// A suffix may be added by <see cref="SimulationDataSet.AutoExpandTasks"/>
		/// iff the task has <see cref="AutoExpandToAllCrewmen"/> set to true.
		/// </summary>
		public string Name
		{
			get { return this.name; }
			set { this.name = value; }
		}

		/// <summary>
		/// Get the name of the task without a suffix possibly added by <see cref="SimulationDataSet.AutoExpandTasks"/>.
		/// </summary>
		public string NameNotExpanded
		{
			get
			{
				var i = this.name.IndexOf('|');
				if (i < 0) return this.name;
				else return this.name.Substring(0, i);
			}
		}

		string description;

		public string Description
		{
			get { return this.description; }
			set { this.description = value; }
		}

		/// <summary>
		/// Cached information inferred from TaskType.
		/// </summary>
		bool isWork;

		public bool IsWork
		{
			get { return this.isWork; }
		}

		bool isPhaseDependent;

		public bool IsPhaseDependent
		{
			get { return this.isPhaseDependent; }
		}

		/// <summary>
		/// Cached information inferred from TaskType.
		/// </summary>
		int taskTypeSubCode1;

		public int TaskTypeSubCode1
		{
			get { return this.taskTypeSubCode1; }
		}

		int taskType;

		public int TaskType
		{
			get { return this.taskType; }
			set
			{
				this.taskType = value;
				this.taskTypeSubCode1 = value.SubCode();
				switch (this.taskTypeSubCode1)
				{
					case (int)StandardTaskType.Idle:
					case (int)StandardTaskType.Rest:
						this.isWork = false;
						break;
					default:
						this.isWork = true;
						break;
				}
			}
		}

		readonly SimulationTask refTask;

		public SimulationTask RefTask	//TODO: Try to remove
		{
			get { return this.refTask; }
		}

		/*/// <summary>
		/// Indicates if the task should be automatically generated by the system (true) because it is obligatory for some internal algorithms,
		/// or is just a normal user task (false).
		/// </summary>
		/// <remarks>
		/// By convention, system task's name should start by a '!'.
		/// </remarks>
		public bool systemTask;*/

		bool autoExpandToAllCrewmen;

		public bool AutoExpandToAllCrewmen
		{
			get { return this.autoExpandToAllCrewmen; }
			set { this.autoExpandToAllCrewmen = value; }
		}

		/// <summary>
		/// Return true if this is an additional tasks resulting from the auto-expansion of a with attribute <see cref="AutoExpandToAllCrewmen"/> set to true, false otherwise.
		/// </summary>
		/// <remarks>
		/// Additional auto-expanded tasks have a name containing a vertical bar '|'.
		/// </remarks>
		public bool IsAutoExpanded
		{
			get { return this.name.Contains('|'); }
		}

		RelativeDateType relativeDate;

		public RelativeDateType RelativeDate
		{
			get { return this.relativeDate; }
			set
			{
				this.relativeDate = value;
				this.isPhaseDependent = this.relativeDate != RelativeDateType.Frequency;
			}
		}

		public TimeDistribution StartDate;	//Do not use a property for structures, otherwise the TimeDistribution struct will not be updatable

		RelativeTimeType relativeTime = RelativeTimeType.TimeWindow;

		public RelativeTimeType RelativeTime
		{
			get { return this.relativeTime; }
			set { this.relativeTime = value; }
		}

		public TimeDistribution DateOffset;

		public SimulationTime DailyHourStart;

		public SimulationTime DailyHourEnd;

		bool onHolidays;

		public bool OnHolidays
		{
			get { return this.onHolidays; }
			set { this.onHolidays = value; }
		}

		public TimeDistribution Duration;

		TaskInterruptionPolicies taskInterruptionPolicy;

		public TaskInterruptionPolicies TaskInterruptionPolicy
		{
			get { return this.taskInterruptionPolicy; }
			set { this.taskInterruptionPolicy = value; }
		}

		PhaseInterruptionPolicies phaseInterruptionPolicy;

		public PhaseInterruptionPolicies PhaseInterruptionPolicy
		{
			get { return this.phaseInterruptionPolicy; }
			set { this.phaseInterruptionPolicy = value; }
		}

		ScenarioInterruptionPolicies scenarioInterruptionPolicy = ScenarioInterruptionPolicies.DropWithoutError;

		public ScenarioInterruptionPolicies ScenarioInterruptionPolicy
		{
			get { return this.scenarioInterruptionPolicy; }
			set { this.scenarioInterruptionPolicy = value; }
		}

		InterruptionTypes interruptionErrorPolicy;

		/// <summary>
		/// (Not used yet) Defines what actions to undertake when a task is interrupted by another task of higher priority.
		/// </summary>
		[Obsolete("Not used/implemented yet!")]
		public InterruptionTypes InterruptionErrorPolicy	//TODO: Use InterruptionErrorPolicy
		{
			get { return this.interruptionErrorPolicy; }
			set { this.interruptionErrorPolicy = value; }
		}

		int priority;

		/// <summary>
		/// Priority of the task relatively to the other tasks.
		/// </summary>
		public int Priority
		{
			get { return this.priority; }
			set { this.priority = value; }
		}

		bool enabled = true;

		/// <summary>
		/// Specifies if the task is used or not in the scenario.
		/// If false, the task will not act like non-existing.
		/// </summary>
		public bool Enabled
		{
			get { return this.RootTask.enabled; }
			set
			{
				this.enabled = value;
				this.RootTask.enabled = value;
			}
		}

		readonly List<int> phaseTypes;

		/// <summary>
		/// List of phase types in which the task is always active.
		/// </summary>
		public List<int> PhaseTypes
		{
			get { return this.phaseTypes; }
		}

		readonly List<int> crewmanTypes;

		/// <summary>
		/// List of crewman types more likelly to be assigned to the task.
		/// </summary>
		[Obsolete("Not used!")]
		public List<int> CrewmanTypes
		{
			get { return this.crewmanTypes; }
		}

		/*readonly List<TaskRelation> relations;

		internal IEnumerable<TaskRelation> Relations
		{
			get { return this.relations; }
		}*/

		int numberOfCrewmenNeeded;

		public int NumberOfCrewmenNeeded
		{
			get { return this.numberOfCrewmenNeeded; }
			set { this.numberOfCrewmenNeeded = value; }
		}

		/// <summary>
		/// Rotation duration. Set to zero to disable rotation.
		/// </summary>
		public SimulationTime Rotation;

		bool noDuplicate;

		public bool NoDuplicate
		{
			get
			{
				return this.noDuplicate;
			}
			set
			{
				this.noDuplicate = value;
			}
		}

		public bool NeedsDuplicateManagement
		{
			get
			{
				return this.noDuplicate ||
					((this.numberOfCrewmenNeeded <= 1) &&	//No optimisation currently for tasks with more than 1 crewman needed
						((this.taskInterruptionPolicy & (TaskInterruptionPolicies.ContinueOrResumeWithError | TaskInterruptionPolicies.ContinueOrResumeWithoutError)) == this.taskInterruptionPolicy));
			}
		}

		readonly Dictionary<int, SimulationTask> parallelTasks;

		public Dictionary<int, SimulationTask> ParallelTasks
		{
			get { return this.parallelTasks; }
		}

		readonly Dictionary<int, SimulationTask> slaveTasks;

		public Dictionary<int, SimulationTask> SlaveTasks
		{
			get { return this.slaveTasks; }
		}

		readonly Dictionary<int, SimulationTask> masterTasks;

		public Dictionary<int, SimulationTask> MasterTasks
		{
			get { return this.masterTasks; }
		}

		protected SimulationTask(int id)
		{
			this.id = id;
			this.phaseTypes = new List<int>();
			this.crewmanTypes = new List<int>();
			this.parallelTasks = new Dictionary<int, SimulationTask>();
			this.slaveTasks = new Dictionary<int, SimulationTask>();
			this.masterTasks = new Dictionary<int, SimulationTask>();
			this.simulationCurrentQualifications = new Dictionary<Crewman, byte>();
		}

		/// <summary>
		/// Create a new task based on a reference task from which the different parameters will be copied.
		/// </summary>
		/// <param name="id">The ID of the new task, potentially different from the reference task.</param>
		/// <param name="refTask">The parent task from which parameters will be copied</param>
		/// <param name="linkingType">Controls the possible sharing with the reference task some data structure</param>
		protected SimulationTask(int id, SimulationTask refTask, TaskLinkingType linkingType)
		{
			this.id = id;
			this.refTask = refTask;
			Reset();
			{//Always linked
				this.crewmanTypes = refTask.crewmanTypes;
				this.phaseTypes = refTask.phaseTypes;
			}
			switch (linkingType)
			{
				case TaskLinkingType.Linked:
					this.simulationCurrentQualifications = refTask.simulationCurrentQualifications;
					this.parallelTasks = refTask.parallelTasks;
					this.slaveTasks = refTask.slaveTasks;
					this.masterTasks = refTask.masterTasks;
					break;
				case TaskLinkingType.Copy:
					//this.crewmanTypes = refTask.crewmanTypes.ToList();
					//this.phaseTypes = refTask.phaseTypes.ToList();
					this.simulationCurrentQualifications = new Dictionary<Crewman, byte>(this.refTask.simulationCurrentQualifications);
					this.parallelTasks = new Dictionary<int, SimulationTask>(this.refTask.parallelTasks);
					this.slaveTasks = new Dictionary<int, SimulationTask>(this.refTask.slaveTasks);
					this.masterTasks = new Dictionary<int, SimulationTask>(this.refTask.masterTasks);
					break;
				case TaskLinkingType.Clear:
				default:
					//this.crewmanTypes = refTask.crewmanTypes.ToList();
					//this.phaseTypes = refTask.phaseTypes.ToList();
					this.simulationCurrentQualifications = new Dictionary<Crewman, byte>(this.refTask.simulationCurrentQualifications);
					this.parallelTasks = new Dictionary<int, SimulationTask>();
					this.slaveTasks = new Dictionary<int, SimulationTask>();
					this.masterTasks = new Dictionary<int, SimulationTask>();
					break;
			}
			this.refTask = refTask.RootTask;
		}

		/// <summary>
		/// Create a new task based on a reference task from which the different parameters will be copied (including task ID).
		/// </summary>
		/// <param name="refTask">The parent task from which parameters will be copied</param>
		/// <param name="linkingType">Controls the possible sharing with the reference task some data structures</param>
		protected SimulationTask(SimulationTask refTask, TaskLinkingType linkingType) : this(refTask.id, refTask, linkingType) { }

		/// <summary>
		/// Reset to the default parameters of the parent Task, except for readonly attributes (e.g. this.id) and lists.
		/// </summary>
		public void Reset()
		{
			if (this.refTask == null)
			{
				this.name = "!Invalid";
				this.TaskType = (int)default(StandardTaskType);
				this.taskInterruptionPolicy = TaskInterruptionPolicies.Undefined;
				this.phaseInterruptionPolicy = PhaseInterruptionPolicies.Undefined;
				this.scenarioInterruptionPolicy = ScenarioInterruptionPolicies.Undefined;
				return;
			}
			this.name = this.refTask.name;
			this.TaskType = this.refTask.taskType;
			//this.systemTask = this.refTask.systemTask;
			this.autoExpandToAllCrewmen = this.refTask.autoExpandToAllCrewmen;
			this.RelativeDate = this.refTask.relativeDate;
			this.DateOffset = this.refTask.DateOffset;
			this.StartDate = this.refTask.StartDate;
			this.relativeTime = this.refTask.relativeTime;
			this.DailyHourStart = this.refTask.DailyHourStart;
			this.DailyHourEnd = this.refTask.DailyHourEnd;
			this.onHolidays = this.refTask.onHolidays;
			this.Duration = this.refTask.Duration;
			this.taskInterruptionPolicy = this.refTask.taskInterruptionPolicy;
			this.phaseInterruptionPolicy = this.refTask.phaseInterruptionPolicy;
			this.scenarioInterruptionPolicy = this.refTask.scenarioInterruptionPolicy;
			this.interruptionErrorPolicy = this.refTask.interruptionErrorPolicy;
			this.priority = this.refTask.priority;
			this.numberOfCrewmenNeeded = this.refTask.numberOfCrewmenNeeded;
			this.Rotation = this.refTask.Rotation;
			this.description = this.refTask.description;
			this.noDuplicate = this.refTask.noDuplicate;
		}

		public SimulationTask RootTask
		{
			get
			{
				var rootTask = this;
				var myTaskRef = this.refTask;
				while (myTaskRef != null)
				{
					rootTask = myTaskRef;
					myTaskRef = rootTask.refTask;
				}
				return rootTask;
			}
		}

		/*/// <summary>
		/// Remove all relations with the task of the specified ID.
		/// </summary>
		/// <param name="task2Id">The ID of the task with which to remove all relations</param>
		public void RemoveRelation(int task2Id)
		{//TODO: Update task2. //TODO: Move to TaskDictionary?
			this.parallelTasks.Remove(task2Id);
			this.slaveTasks.Remove(task2Id);
			this.masterTasks.Remove(task2Id);
		}*/

		#region Task relation shortcuts
		/*public IEnumerable<Task> ParallelTasks
		{
			get
			{
				return this.relations.Where(r => r.Relation == TaskRelation.RelationType.Parallel).Select(r => r.Task1.id == this.id ? r.Task2 : r.Task1);
			}
			set
			{
				foreach (var task in this.ParallelTasks)
					for (var i = task.relations.Count - 1; i >= 0; i--)
					{
						var relation = task.relations[i];
						if ((relation.Relation == TaskRelation.RelationType.Parallel) &&
							((relation.Task1.id == this.id) || (relation.Task2.id == this.id)))
							task.relations.RemoveAt(i);
					}
				this.relations.RemoveAll(r => r.Relation == TaskRelation.RelationType.Parallel);
				if (value != null)
					foreach (var task in value)
					{
						var relation = new TaskRelation(this, TaskRelation.RelationType.Parallel, task);
						this.relations.Add(relation);
						task.relations.Add(relation);
					}
			}
		}

		public IEnumerable<Task> SlaveTasks
		{
			get
			{
				return this.relations.Where(r => (r.Relation == TaskRelation.RelationType.Slave) && (r.Task2.id != this.id)).Select(r => r.Task2);
			}
			set
			{
				foreach (var task in this.SlaveTasks)
					for (var i = task.relations.Count - 1; i >= 0; i--)
					{
						var relation = task.relations[i];
						if ((relation.Relation == TaskRelation.RelationType.Slave) && (relation.Task1.id == this.id))
							task.relations.RemoveAt(i);
					}
				this.relations.RemoveAll(r => (r.Relation == TaskRelation.RelationType.Slave) && (r.Task2.id != this.id));
				if (value != null)
					foreach (var task in value)
					{
						var relation = new TaskRelation(this, TaskRelation.RelationType.Slave, task);
						this.relations.Add(relation);
						task.relations.Add(relation);
					}
			}
		}

		public IEnumerable<Task> MasterTasks
		{//TODO: Optimise hot path
			get
			{
				return this.relations.Where(r => (r.Relation == TaskRelation.RelationType.Slave) && (r.Task1.id != this.id)).Select(r => r.Task1);
			}
			set
			{
				foreach (var task in this.MasterTasks)
					for (var i = task.relations.Count - 1; i >= 0; i--)
					{
						var relation = task.relations[i];
						if ((relation.Relation == TaskRelation.RelationType.Slave) && (relation.Task2.id == this.id))
							task.relations.RemoveAt(i);
					}
				this.relations.RemoveAll(r => (r.Relation == TaskRelation.RelationType.Slave) && (r.Task1.id != this.id));
				if (value != null)
					foreach (var task in value)
					{
						var relation = new TaskRelation(task, TaskRelation.RelationType.Slave, this);
						this.relations.Add(relation);
						task.relations.Add(relation);
					}
			}
		}*/
		#endregion

		public virtual bool Identical(SimulationTask task2)
		{
			if ((task2 == null) || (this.id != task2.id) || (this.name != task2.name) ||	//Do not compare description
				((!((this.Duration.Unit == TimeUnit.Undefined) && (task2.Duration.Unit == TimeUnit.Undefined))) && (this.Duration != task2.Duration)) ||
				/*(this.systemTask != task2.systemTask) ||*/ (this.autoExpandToAllCrewmen != task2.autoExpandToAllCrewmen) ||
				(this.taskInterruptionPolicy != task2.taskInterruptionPolicy) || (this.phaseInterruptionPolicy != task2.phaseInterruptionPolicy) || (this.scenarioInterruptionPolicy != task2.scenarioInterruptionPolicy) ||
				(this.interruptionErrorPolicy != task2.interruptionErrorPolicy) ||
				(this.noDuplicate != task2.noDuplicate) || (this.Rotation != task2.Rotation) || (this.numberOfCrewmenNeeded != task2.numberOfCrewmenNeeded) ||
				(this.onHolidays != task2.onHolidays) || (this.priority != task2.priority) || (this.relativeDate != task2.relativeDate) ||
				(this.taskType != task2.taskType) || (this.relativeTime != task2.relativeTime) ||
				((!((this.StartDate.Unit == TimeUnit.Undefined) && (task2.StartDate.Unit == TimeUnit.Undefined))) && (this.StartDate != task2.StartDate)) ||
				((!((this.DateOffset.Unit == TimeUnit.Undefined) && (task2.DateOffset.Unit == TimeUnit.Undefined))) && (this.DateOffset != task2.DateOffset)) ||
				(this.DailyHourEnd != task2.DailyHourEnd) || (this.DailyHourStart != task2.DailyHourStart) ||
				(!this.phaseTypes.OrderBy(i => i).SequenceEqual(task2.phaseTypes.OrderBy(i => i))) || (!this.crewmanTypes.SequenceEqual(task2.crewmanTypes)) ||
				(this.parallelTasks.Count != task2.parallelTasks.Count) || (this.slaveTasks.Count != task2.slaveTasks.Count) || (this.masterTasks.Count != task2.masterTasks.Count))
				return false;
			foreach (var otherTaskId in this.parallelTasks.Values.Select(t => t.id))
				if (!task2.parallelTasks.ContainsKey(otherTaskId))
					return false;
			foreach (var otherTaskId in this.slaveTasks.Values.Select(t => t.id))
				if (!task2.slaveTasks.ContainsKey(otherTaskId))
					return false;
			foreach (var otherTaskId in this.masterTasks.Values.Select(t => t.id))
				if (!task2.masterTasks.ContainsKey(otherTaskId))
					return false;
			return true;
		}

		/// <summary>
		/// Returns true if the task must be assigned to someone, false otherwise.
		/// </summary>
		public virtual bool EnforceAssignment
		{
			get
			{
				switch (this.taskTypeSubCode1)
				{
					case (int)StandardTaskType.Idle:
					case (int)StandardTaskType.Rest:
						return false;
					default:
						return true;
				}
			}
		}

		/// <summary>
		/// Tells if the task correctly assigned in a given crew or not.
		/// </summary>
		/// <param name="crew">A crew</param>
		/// <returns>True if the task is assigned to enough crewmen in the given crew, false otherwise.</returns>
		public bool IsAssigned(Crew crew)
		{
			int needed = this.numberOfCrewmenNeeded;
			if (needed <= 0) return true;
			if (crew == null) return false;
			if (this.autoExpandToAllCrewmen) return true;
			byte percentage;
			if (this.numberOfCrewmenNeeded > 0)
			{
				foreach (var crewman in crew.Values.Where(cm => cm.Id > 0))
					if (crewman.Qualifications.TryGetValue(this.id, out percentage) && (percentage > 0))
					{
						needed--;
						if (needed <= 0) break;
					}
				return needed <= 0;
			}
			else	//A task with no crew-member needed must not have anybody assigned.
			{
				foreach (var crewman in crew.Values.Where(cm => cm.Id > 0))
					if (crewman.Qualifications.TryGetValue(this.id, out percentage) && (percentage > 0))
						return false;
				return true;
			}
		}

		/// <summary>
		/// Tells if the task is allowed to be executed in a given phase or not.
		/// </summary>
		/// <param name="phase">A phase</param>
		/// <returns>True if the task is allowed to be executed in the given phase, false otherwise.</returns>
		public bool Allowed(Phase phase)
		{
			return phase.Tasks.ContainsKey(this.id) || this.phaseTypes.Any(pt => phase.PhaseType.IsSubCodeOf(pt)) ||
				this.masterTasks.Values.Any(t => t.Allowed(phase));	//Recursion
		}

		public void Validate()
		{
			#pragma warning disable 618	//Disable warning for obsolete "DoNotInterrupt"
			if (this.phaseInterruptionPolicy == PhaseInterruptionPolicies.DoNotInterrupt)
			#pragma warning restore 618
			{//Back compatibility
				this.taskInterruptionPolicy = TaskInterruptionPolicies.ContinueOrResumeWithError;
				this.phaseInterruptionPolicy = PhaseInterruptionPolicies.ContinueOrDropWithError;
			}
			if (this.taskType.IsSubCodeOf(StandardTaskType.ExternalCondition) ||
				this.taskType.IsSubCodeOf(StandardTaskType.CriticalEvents))
			{
				this.taskInterruptionPolicy = TaskInterruptionPolicies.DropWithError;
				this.phaseInterruptionPolicy = PhaseInterruptionPolicies.ResumeOrDropWithError;
				this.scenarioInterruptionPolicy = ScenarioInterruptionPolicies.DropWithoutError;
				//this.relativeTime = Task.RelativeTimeType.TimeWindow;
				//this.dailyHourStart = TimeSpan.Zero;
				//this.dailyHourEnd = TimeSpan.Zero;
				//this.onHolidays = true;
				this.autoExpandToAllCrewmen = false;
				this.numberOfCrewmenNeeded = 0;
				this.Rotation = SimulationTime.Zero;
				this.noDuplicate = true;
				this.masterTasks.Clear();
				this.parallelTasks.Clear();
				this.priority = 700;
			}
			else
			{
				this.slaveTasks.Clear();	//Only external conditions can have slaves
				if (this.relativeDate == RelativeDateType.TriggeredByAnEvent)
				{
					this.StartDate = TimeDistribution.Zero;
					this.Duration = new TimeDistribution(SimulationTime.ArbitraryLargeDuration);
					this.noDuplicate = true;
					this.parallelTasks.Clear();
					this.phaseTypes.Clear();
				}
				else this.masterTasks.Clear();
				if (this.phaseInterruptionPolicy == PhaseInterruptionPolicies.WholePhase)
				{
					this.DailyHourStart = SimulationTime.Zero;
					this.DailyHourEnd = SimulationTime.Zero;
					this.RelativeDate = RelativeDateType.RelativeStartFromStartOfPhase;
					this.StartDate = TimeDistribution.Zero;
					this.Duration = new TimeDistribution(SimulationTime.ArbitraryLargeDuration);
					this.parallelTasks.Clear();
				}
				else if ((this.phaseInterruptionPolicy == PhaseInterruptionPolicies.Obligatory) &&
					(this.relativeDate != RelativeDateType.RelativeStartFromStartOfPhase) &&
					(this.relativeDate != RelativeDateType.RelativeStartFromEndOfPhase) &&
					(this.relativeDate != RelativeDateType.RelativeStopFromEndOfPhase))
					this.phaseInterruptionPolicy = PhaseInterruptionPolicies.DropWithError;
				switch (this.relativeDate)
				{
					case RelativeDateType.RelativeStopFromEndOfPhase:
					case RelativeDateType.RelativeStartFromStartOfPhase:
					case RelativeDateType.RelativeStartFromEndOfPhase:
					case RelativeDateType.RelativeStartFromPreviousStart:
						this.DateOffset = default(TimeDistribution);
						break;
				}
				if (((this.relativeDate == RelativeDateType.AbsoluteStartMonthDay) ||
					(this.relativeDate == RelativeDateType.AbsoluteStartWeekDay)))
					this.StartDate.Unit = TimeUnit.Days;
				if (this.autoExpandToAllCrewmen)
				{
					this.numberOfCrewmenNeeded = 1;
					this.Rotation = SimulationTime.Zero;
				}
			}
			this.Duration.Validate();
			this.StartDate.Validate();
		}

		public bool Valid
		{
			get { return this.enabled && String.IsNullOrEmpty(this.ErrorMessage); }
		}

		public virtual string ErrorMessage
		{
			get
			{
				if (this.id == 0)
					return "Invalid task ID!";
				if ((this.taskType <= (int)StandardTaskType.Idle) ||
					(this.Duration.Unit == TimeUnit.Undefined) ||
					(this.taskInterruptionPolicy == TaskInterruptionPolicies.Undefined) ||
					(this.phaseInterruptionPolicy == PhaseInterruptionPolicies.Undefined) ||
					(this.scenarioInterruptionPolicy == ScenarioInterruptionPolicies.Undefined) ||
					(this.relativeDate == RelativeDateType.Undefined) ||
					(this.relativeTime == RelativeTimeType.Undefined) ||
					(this.StartDate.Unit == TimeUnit.Undefined))
					return "Some types are undefined!";
				if ((this.priority <= 0) || (this.priority > 1000))
					return "Priority out of range ]0..1000]!";
				if (this.taskType.IsSubCodeOf(StandardTaskType.ExternalCondition) || this.taskType.IsSubCodeOf(StandardTaskType.CriticalEvents))
				{
					if (this.Duration.Distribution == ProbabilityDistribution.Exponential)
						return "Only external conditions and critical events can have a duration defined as an exponential distribution (0, mean, 0)!";
				}
				else if (this.slaveTasks.Count > 0)
					return "Only external conditions and critical events can have slaves!";
				if ((this.phaseInterruptionPolicy == PhaseInterruptionPolicies.WholePhase) &&
					((this.relativeDate != RelativeDateType.RelativeStartFromStartOfPhase) || (this.StartDate.MaxPossible > SimulationTime.Zero)))
					return "Tasks lasting “WholePhase” must be with a date “RelativeStartFromStartOfPhase, 0”!";
				if ((this.phaseInterruptionPolicy == PhaseInterruptionPolicies.Obligatory) &&
					(this.relativeDate != RelativeDateType.RelativeStartFromStartOfPhase) &&
					(this.relativeDate != RelativeDateType.RelativeStartFromEndOfPhase) &&
					(this.relativeDate != RelativeDateType.RelativeStopFromEndOfPhase))
					return "Obligatory tasks must have a date relative to the start or the end of the phase!";
				if (((this.relativeDate == RelativeDateType.AbsoluteStartMonthDay) ||
					(this.relativeDate == RelativeDateType.AbsoluteStartWeekDay)) &&
					(this.StartDate.Unit != TimeUnit.Days))
					return "Tasks starting on a specific day must use “Days” as time unit!";
				if ((this.relativeDate == RelativeDateType.AbsoluteStartMonthDay) &&
					(this.StartDate.MaxPossible.Ticks > SimulationTime.TicksPerMonth))
					return "Invalid month day number for start date!";
				if ((this.relativeDate == RelativeDateType.AbsoluteStartWeekDay) &&
					(this.StartDate.MaxPossible.Ticks > SimulationTime.TicksPerWeek))
					return "Invalid week day number for start date!";
				if (((this.relativeDate == RelativeDateType.RelativeStartFromPreviousStart) || (this.relativeDate == RelativeDateType.Frequency)) &&
					(this.StartDate.Average < this.Duration.Average))
					return "Tasks using frequency, or relative to the start of the previous occurence, must have an average duration lower than the average time since the last occurence!";
				if ((this.relativeTime == RelativeTimeType.AbsoluteStopTime) && (this.Duration.MaxPossible > SimulationTime.DayTimeOffset(this.DailyHourStart, this.DailyHourEnd)))
					return "Tasks using an absolute stop time must last less than than their daily time window!";
				if (this.autoExpandToAllCrewmen && (this.numberOfCrewmenNeeded != 1))
					return "Automatic tasks cannot be assigned to multiple crew-members!";
				if (this.relativeDate == RelativeDateType.TriggeredByAnEvent)
				{
					if (this.slaveTasks.Count > 0) return "Tasks triggered by an event must not have any slaves!";
				}
				else
				{
					if (this.masterTasks.Count > 0)
						return "Only tasks triggered by an event can have masters!";
					if ((this.phaseInterruptionPolicy != PhaseInterruptionPolicies.WholePhase) &&
						(this.Duration.MaxPossible > Phase.ArbitraryMaxDuration))
						return String.Format(CultureInfo.InvariantCulture, "The duration of this task must not exceed {0} days!", Phase.ArbitraryMaxDuration.TotalDays);
					if ((!this.noDuplicate) && (this.parallelTasks.Count > 0))
						return "Parallel tasks must disallow duplicates!";
				}
				/*foreach (var relation in this.relations)
				{
					var result = relation.ErrorMessage;
					if (!String.IsNullOrEmpty(result))
						return "Invalid relation: " + result;
				}*/
				return String.Empty;
			}
		}

		public virtual string WarningMessage
		{
			get
			{
				var result = String.Empty;
				foreach (var task2 in this.parallelTasks.Values)
				{
					if ((this.onHolidays != task2.onHolidays) || (this.priority != task2.priority) ||
						(this.Duration != task2.Duration) ||
						(this.relativeDate != task2.relativeDate) || (this.relativeTime != task2.relativeTime) ||
						(this.StartDate != task2.StartDate) ||
						(this.DailyHourStart != task2.DailyHourStart) || (this.DailyHourEnd != task2.DailyHourEnd))
						result += " Inconsistent values between parallel tasks!";
					if (!task2.parallelTasks.ContainsKey(this.id))
						result += String.Format(CultureInfo.InvariantCulture, " Invalid reciprocal parallel-parallel relation with task {0}!", task2.id);
					if (task2.id == this.id)
						result += " A task should not be explicitly parallel with itself!";
				}
				if ((this.relativeDate == RelativeDateType.TriggeredByAnEvent) && (this.masterTasks.Count <= 0))
					result += " Tasks triggered by an event should have at least one master!";
				if ((this.slaveTasks.Count <= 0) && (this.taskType.IsSubCodeOf(StandardTaskType.ExternalCondition) || this.taskType.IsSubCodeOf(StandardTaskType.CriticalEvents)))
					result += " External conditions and critical events are meant to trigger at least one task (slave).";
				foreach (var task2 in this.masterTasks.Values)
					if (!task2.slaveTasks.ContainsKey(this.id))
						result += String.Format(CultureInfo.InvariantCulture, " Invalid reciprocal master-slave relation with task {0}!", task2.id);
				foreach (var task2 in this.slaveTasks.Values)
					if (!task2.masterTasks.ContainsKey(this.id))
						result += String.Format(CultureInfo.InvariantCulture, " Invalid reciprocal slave-master relation with task {0}!", task2.id);
				return result;
			}
		}

		public override string ToString()
		{
			return String.Concat(this.id, '.', this.name);
		}

		public string Details
		{
			get
			{//TODO: Use format
				var stringBuilder = new StringBuilder();
				stringBuilder.Append(this.relativeDate.ToString()).Append(": ").Append(this.StartDate.ToString()).Append("; offset: ").
					Append(this.DateOffset.Unit == TimeUnit.Undefined ? "auto" : this.DateOffset.ToString()).Append("; ").
					Append(this.relativeTime.ToString()).Append(": ").Append(this.DailyHourStart.ToStringHourUI()).Append(" ‣ ").Append(this.DailyHourEnd.ToStringHourUI()).
					Append(this.onHolidays ? " ⑦" : " ⑥").Append("; ").AppendFormat("[Interruptions: task:{0}, phase:{1}, end:{2}]; ", this.taskInterruptionPolicy, this.phaseInterruptionPolicy, this.scenarioInterruptionPolicy).
					Append(this.Duration.ToString()).Append("; Priority: ").Append(this.priority).Append("; ").
					Append(this.numberOfCrewmenNeeded).Append("CM");
				if (this.Rotation > SimulationTime.Zero)
					stringBuilder.Append(" ∞").Append(this.Rotation.TotalHours).Append('h');
				return stringBuilder.ToString();
			}
		}

		#region IO
		protected internal virtual bool LoadFromXml(XElement xmlTask)
		{//TODO: Error messages
			XAttribute attr;
			this.name = (attr = xmlTask.Attribute("name")) == null ? String.Empty : attr.Value;
			this.TaskType = xmlTask.Attribute("taskType").ParseInteger();
			//this.systemTask = (attr = xmlTask.Attribute("systemTask")) == null ? false : attr.Value.ParseBoolean();
			this.autoExpandToAllCrewmen = (attr = xmlTask.Attribute("autoAssignToAllCrewMembers")) == null ? false : attr.Value.ParseBoolean();
			this.RelativeDate = (attr = xmlTask.Attribute("relativeDate")) == null ? RelativeDateType.Undefined : SimulationTask.ParseRelativeDateType(attr.Value);
			this.StartDate = XmlIO.ParseTimeDistribution(xmlTask.Attribute("startDateUnit"),
				xmlTask.Attribute("startDateMin"), xmlTask.Attribute("startDateMean"), xmlTask.Attribute("startDateMax"));
			if (this.relativeDate == RelativeDateType.Frequency)
				this.DateOffset = XmlIO.ParseTimeDistribution(xmlTask.Attribute("dateOffsetUnit"),
					xmlTask.Attribute("dateOffsetMin"), xmlTask.Attribute("dateOffsetMean"), xmlTask.Attribute("dateOffsetMax"));
			this.relativeTime = xmlTask.Attribute("relativeTime").ParseRelativeTimeType();
			this.DailyHourStart = xmlTask.Attribute("workingHourStart").ParseSimulationTime(TimeUnit.Hours);
			this.DailyHourEnd = xmlTask.Attribute("workingHourEnd").ParseSimulationTime(TimeUnit.Hours);
			this.onHolidays = xmlTask.Attribute("onHolidays").ParseBoolean();
			this.enabled = (attr = xmlTask.Attribute("enabled")) == null ? true : attr.ParseBoolean();
			this.Duration = XmlIO.ParseTimeDistribution(xmlTask.Attribute("taskDurationUnit"),
				xmlTask.Attribute("taskDurationMin"), xmlTask.Attribute("taskDurationMean"), xmlTask.Attribute("taskDurationMax"));
			attr = xmlTask.Attribute("taskInterruptionPolicy");
			if (attr == null) this.taskInterruptionPolicy = TaskInterruptionPolicies.ContinueOrResumeWithoutError;	//Back compatibility behaviour
			else this.taskInterruptionPolicy = attr.ParseTaskInterruptionPolicy();
			attr = xmlTask.Attribute("phaseInterruptionPolicy");
			if (attr == null)
			{
				attr = xmlTask.Attribute("interruptibility");	//Backward compatibility
				if (attr == null) attr = xmlTask.Attribute("interruptability");	//Spelling compatibility
			}
			this.phaseInterruptionPolicy = attr.ParsePhaseInterruptionPolicy();
			attr = xmlTask.Attribute("scenarioInterruptionPolicy");
			if (attr == null) this.scenarioInterruptionPolicy = ScenarioInterruptionPolicies.DropWithoutError;	//Back compatibility behaviour
			else this.scenarioInterruptionPolicy = attr.ParseScenarioInterruptionPolicy();
			this.priority = xmlTask.Attribute("priority").ParseInteger();
			this.numberOfCrewmenNeeded = xmlTask.Attribute("numberOfCrewMembersNeeded").ParseInteger();
			if ((attr = xmlTask.Attribute("rotation")) != null)
				this.Rotation = new SimulationTime(TimeUnit.Hours, Math.Min(24.0, Math.Max(0.0, attr.Value.ParseReal())));
			else if ((attr = xmlTask.Attribute("isRotating")) != null)	//Compatibility
				this.Rotation = new SimulationTime(TimeUnit.Hours, attr.Value.ParseBoolean() ? 6 : 0);	//Previously hard-coded to 6-hour rotation
			else this.Rotation = SimulationTime.Zero;
			XElement elem;
			this.description = (elem = xmlTask.Element("description")) == null ? String.Empty : elem.Value;
			elem = xmlTask.Element("phaseTypes");
			if (elem != null)
				foreach (var phaseTypeRef in elem.Elements("PhaseTypeRef"))
				{
					attr = phaseTypeRef.Attribute("refCode");
					if (attr != null) this.phaseTypes.Add(attr.Value.ParseInteger());
				}
			elem = xmlTask.Element("crewMemberTypes");
			if (elem != null)
				foreach (var phaseTypeRef in elem.Elements("CrewMemberTypeRef"))
				{
					attr = phaseTypeRef.Attribute("refCode");
					if (attr != null) this.crewmanTypes.Add(attr.Value.ParseInteger());
				}
			this.noDuplicate = (attr = xmlTask.Attribute("noDuplicate")) == null ? false : attr.Value.ParseBoolean();
			//Task relations are loaded by TaskDictionary
			return true;
		}

		protected internal virtual void SaveToXml(XmlWriter xmlWriter)
		{
			//if (this.systemTask) return;	//Do not save system tasks
			xmlWriter.WriteStartElement("Task");
			xmlWriter.WriteAttributeString("id", this.id.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("name", this.name);
			xmlWriter.WriteAttributeString("taskType", this.taskType.ToString(CultureInfo.InvariantCulture));
			//xmlWriter.WriteAttributeString("systemTask", this.systemTask.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("autoAssignToAllCrewMembers", this.autoExpandToAllCrewmen.ToString());
			xmlWriter.WriteAttributeString("relativeDate", this.relativeDate.ToString());
			xmlWriter.WriteAttributeString("startDateUnit", this.StartDate.Unit.ToString());
			xmlWriter.WriteAttributeString("startDateMin", this.StartDate.Min.ToStringRaw());
			xmlWriter.WriteAttributeString("startDateMean", this.StartDate.Mode.ToStringRaw());
			xmlWriter.WriteAttributeString("startDateMax", this.StartDate.Max.ToStringRaw());
			if ((this.relativeDate == RelativeDateType.Frequency) && (this.DateOffset.Unit != TimeUnit.Undefined))
			{
				xmlWriter.WriteAttributeString("dateOffsetUnit", this.DateOffset.Unit.ToString());
				xmlWriter.WriteAttributeString("dateOffsetMin", this.DateOffset.Min.ToStringRaw());
				xmlWriter.WriteAttributeString("dateOffsetMean", this.DateOffset.Mode.ToStringRaw());
				xmlWriter.WriteAttributeString("dateOffsetMax", this.DateOffset.Max.ToStringRaw());
			}
			xmlWriter.WriteAttributeString("relativeTime", this.relativeTime.ToString());
			xmlWriter.WriteAttributeString("workingHourStart", this.DailyHourStart.ToStringRaw());
			xmlWriter.WriteAttributeString("workingHourEnd", this.DailyHourEnd.ToStringRaw());
			xmlWriter.WriteAttributeString("onHolidays", this.onHolidays.ToString());
			if (!this.enabled)
				xmlWriter.WriteAttributeString("enabled", this.enabled.ToString());
			xmlWriter.WriteAttributeString("taskDurationUnit", this.Duration.Unit.ToString());
			xmlWriter.WriteAttributeString("taskDurationMin", this.Duration.Min.ToStringRaw());
			xmlWriter.WriteAttributeString("taskDurationMean", this.Duration.Mode.ToStringRaw());
			xmlWriter.WriteAttributeString("taskDurationMax", this.Duration.Max.ToStringRaw());
			//xmlWriter.WriteAttributeString("frequencyUnit", task.FrequencyUnit.ToString());
			//xmlWriter.WriteAttributeString("frequency", task.Frequency.ToTimeEntry(this.frequencyUnit));
			//xmlWriter.WriteAttributeString("occurrences", task.Occurrences.ToString());
			xmlWriter.WriteAttributeString("taskInterruptionPolicy", this.taskInterruptionPolicy.ToString());
			xmlWriter.WriteAttributeString("phaseInterruptionPolicy", this.phaseInterruptionPolicy.ToString());
			xmlWriter.WriteAttributeString("scenarioInterruptionPolicy", this.scenarioInterruptionPolicy.ToString());
			xmlWriter.WriteAttributeString("interruptionErrorPolicy", this.interruptionErrorPolicy.ToString());
			xmlWriter.WriteAttributeString("priority", this.priority.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("numberOfCrewMembersNeeded", this.numberOfCrewmenNeeded.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("rotation", this.Rotation.TotalHours.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("noDuplicate", this.noDuplicate.ToString());
			if (!String.IsNullOrWhiteSpace(this.description))
				xmlWriter.WriteElementString("description", this.description);
			xmlWriter.WriteStartElement("phaseTypes");
			foreach (var phaseType in this.phaseTypes)
			{
				xmlWriter.WriteStartElement("PhaseTypeRef");
				xmlWriter.WriteAttributeString("refCode", phaseType.ToString(CultureInfo.InvariantCulture));
				xmlWriter.WriteEndElement();
			}
			xmlWriter.WriteEndElement();
			xmlWriter.WriteStartElement("crewMemberTypes");
			foreach (var crewmanType in this.crewmanTypes)
			{
				xmlWriter.WriteStartElement("CrewMemberTypeRef");
				xmlWriter.WriteAttributeString("refCode", crewmanType.ToString(CultureInfo.InvariantCulture));
				xmlWriter.WriteEndElement();
			}
			xmlWriter.WriteEndElement();
			xmlWriter.WriteStartElement("taskRelations");
			//var relStr = ((int)TaskRelation.RelationType.Parallel).ToString(CultureInfo.InvariantCulture);
			var relStr = TaskRelation.RelationType.Parallel.ToString();
			foreach (var taskId2 in this.parallelTasks.Keys)
			{
				xmlWriter.WriteStartElement("TaskRef");
				xmlWriter.WriteAttributeString("rel", relStr);
				xmlWriter.WriteAttributeString("refId", taskId2.ToString(CultureInfo.InvariantCulture));
				xmlWriter.WriteEndElement();
			}
			//relStr = ((int)TaskRelation.RelationType.Slave).ToString(CultureInfo.InvariantCulture);
			relStr = TaskRelation.RelationType.Slave.ToString();
			foreach (var taskId2 in this.slaveTasks.Keys)
			{
				xmlWriter.WriteStartElement("TaskRef");
				xmlWriter.WriteAttributeString("rel", relStr);
				xmlWriter.WriteAttributeString("refId", taskId2.ToString(CultureInfo.InvariantCulture));
				xmlWriter.WriteEndElement();
			}
			//relStr = ((int)TaskRelation.RelationType.Master).ToString(CultureInfo.InvariantCulture);
			relStr = TaskRelation.RelationType.Master.ToString();
			foreach (var taskId2 in this.masterTasks.Keys)
			{
				xmlWriter.WriteStartElement("TaskRef");
				xmlWriter.WriteAttributeString("rel", relStr);
				xmlWriter.WriteAttributeString("refId", taskId2.ToString(CultureInfo.InvariantCulture));
				xmlWriter.WriteEndElement();
			}
			xmlWriter.WriteEndElement();
			xmlWriter.WriteEndElement();
		}

		protected internal virtual bool LoadRefFromXml(XElement xmlTaskRef)
		{
			XAttribute attr;
			var timeUnit = (attr = xmlTaskRef.Attribute("startDateUnit")) == null ? this.refTask.StartDate.Unit : attr.Value.ParseTimeUnit();
			this.StartDate = new TimeDistribution(timeUnit,
				(attr = xmlTaskRef.Attribute("startDateMin")) == null ? this.refTask.StartDate.Min : new SimulationTime(timeUnit, attr.Value),
				(attr = xmlTaskRef.Attribute("startDateMean")) == null ? this.refTask.StartDate.Mode : new SimulationTime(timeUnit, attr.Value),
				(attr = xmlTaskRef.Attribute("startDateMax")) == null ? this.refTask.StartDate.Max : new SimulationTime(timeUnit, attr.Value));
			if (this.relativeDate == RelativeDateType.Frequency)
			{
				timeUnit = (attr = xmlTaskRef.Attribute("dateOffsetUnit")) == null ? this.refTask.DateOffset.Unit : attr.Value.ParseTimeUnit();
				this.DateOffset = new TimeDistribution(timeUnit,
					(attr = xmlTaskRef.Attribute("dateOffsetMin")) == null ? this.refTask.DateOffset.Min : new SimulationTime(timeUnit, attr.Value),
					(attr = xmlTaskRef.Attribute("dateOffsetMean")) == null ? this.refTask.DateOffset.Mode : new SimulationTime(timeUnit, attr.Value),
					(attr = xmlTaskRef.Attribute("dateOffsetMax")) == null ? this.refTask.DateOffset.Max : new SimulationTime(timeUnit, attr.Value));
			}
			if ((attr = xmlTaskRef.Attribute("workingHourStart")) != null)
				this.DailyHourStart = new SimulationTime(TimeUnit.Hours, attr.Value);
			if ((attr = xmlTaskRef.Attribute("workingHourEnd")) != null)
				this.DailyHourEnd = new SimulationTime(TimeUnit.Hours, attr.Value);
			if ((attr = xmlTaskRef.Attribute("onHolidays")) != null)
				this.onHolidays = attr.Value.ParseBoolean();
			timeUnit = (attr = xmlTaskRef.Attribute("taskDurationUnit")) == null ? this.refTask.Duration.Unit : attr.Value.ParseTimeUnit();
			this.Duration = new TimeDistribution(timeUnit,
				(attr = xmlTaskRef.Attribute("taskDurationMin")) == null ? this.refTask.Duration.Min : new SimulationTime(timeUnit, attr.Value),
				(attr = xmlTaskRef.Attribute("taskDurationMean")) == null ? this.refTask.Duration.Mode : new SimulationTime(timeUnit, attr.Value),
				(attr = xmlTaskRef.Attribute("taskDurationMax")) == null ? this.refTask.Duration.Max : new SimulationTime(timeUnit, attr.Value));
			if ((attr = xmlTaskRef.Attribute("priority")) != null)
				this.priority = attr.Value.ParseInteger();
			if ( (attr = xmlTaskRef.Attribute("numberOfCrewMembersNeeded")) != null)
				this.numberOfCrewmenNeeded = attr.Value.ParseInteger();
			if ((attr = xmlTaskRef.Attribute("rotation")) != null)
				this.Rotation = new SimulationTime(TimeUnit.Hours, Math.Min(24.0, Math.Max(0, attr.Value.ParseReal())));
			else if ((attr = xmlTaskRef.Attribute("isRotating")) != null)	//Compatibility
				this.Rotation = new SimulationTime(TimeUnit.Hours, attr.Value.ParseBoolean() ? 6.0 : 0.0);	//Previously hard-coded to 6-hour rotation
			XElement elem;
			if ((elem = xmlTaskRef.Element("description")) != null)
				this.description = elem.Value;
			return true;
		}

		protected internal virtual void SaveRefToXml(XmlWriter xmlWriter)
		{
			//if (this.systemTask) return;	//Do not save system tasks
			xmlWriter.WriteStartElement("TaskRef");
			xmlWriter.WriteAttributeString("refId", this.id.ToString(CultureInfo.InvariantCulture));
			xmlWriter.WriteAttributeString("informativeName", this.name);
			//Override values
			//if (this.relativeDate != this.refTask.relativeDate) xmlWriter.WriteAttributeString("relativeDate", this.relativeDate.ToString());
			//if (this.autoAssignToAllCrewMembers != this.refTask.autoAssignToAllCrewMembers) xmlWriter.WriteAttributeString("autoAssignToAllCrewMembers", this.autoAssignToAllCrewMembers.ToString(CultureInfo.InvariantCulture));
			if (this.StartDate.Unit != this.refTask.StartDate.Unit)
				xmlWriter.WriteAttributeString("startDateUnit", this.StartDate.Unit.ToString());
			if (this.StartDate.Min != this.refTask.StartDate.Min)
				xmlWriter.WriteAttributeString("startDateMin", this.StartDate.Min.ToStringRaw());
			if (this.StartDate.Mode != this.refTask.StartDate.Mode)
				xmlWriter.WriteAttributeString("startDateMean", this.StartDate.Mode.ToStringRaw());
			if (this.StartDate.Max != this.refTask.StartDate.Max)
				xmlWriter.WriteAttributeString("startDateMax", this.StartDate.Max.ToStringRaw());
			if (this.relativeDate == RelativeDateType.Frequency)
			{
				if (this.DateOffset.Unit != this.refTask.DateOffset.Unit)
					xmlWriter.WriteAttributeString("dateOffsetUnit", this.DateOffset.Unit.ToString());
				if (this.DateOffset.Min != this.refTask.DateOffset.Min)
					xmlWriter.WriteAttributeString("dateOffsetMin", this.DateOffset.Min.ToStringRaw());
				if (this.DateOffset.Mode != this.refTask.StartDate.Mode)
					xmlWriter.WriteAttributeString("dateOffsetMean", this.DateOffset.Mode.ToStringRaw());
				if (this.DateOffset.Max != this.refTask.StartDate.Max)
					xmlWriter.WriteAttributeString("dateOffsetMax", this.DateOffset.Max.ToStringRaw());
			}
			//if (this.relativeTime != this.refTask.relativeTime) xmlWriter.WriteAttributeString("relativeTime", this.relativeTime.ToString());
			if (this.DailyHourStart != this.refTask.DailyHourStart)
				xmlWriter.WriteAttributeString("workingHourStart", this.DailyHourStart.ToStringRaw());
			if (this.DailyHourEnd != this.refTask.DailyHourEnd)
				xmlWriter.WriteAttributeString("workingHourEnd", this.DailyHourEnd.ToStringRaw());
			if (this.onHolidays != this.refTask.OnHolidays)
				xmlWriter.WriteAttributeString("onHolidays", this.onHolidays.ToString());
			if (this.Duration.Unit != this.refTask.Duration.Unit)
				xmlWriter.WriteAttributeString("taskDurationUnit", this.Duration.Unit.ToString());
			if (this.Duration.Min != this.refTask.Duration.Min)
				xmlWriter.WriteAttributeString("taskDurationMin", this.Duration.Min.ToStringRaw());
			if (this.Duration.Mode != this.refTask.Duration.Mode)
				xmlWriter.WriteAttributeString("taskDurationMean", this.Duration.Mode.ToStringRaw());
			if (this.Duration.Max != this.refTask.Duration.Max)
				xmlWriter.WriteAttributeString("taskDurationMax", this.Duration.Max.ToStringRaw());
			if (this.priority != this.refTask.Priority)
				xmlWriter.WriteAttributeString("priority", this.priority.ToString(CultureInfo.InvariantCulture));
			if (this.numberOfCrewmenNeeded != this.refTask.NumberOfCrewmenNeeded)
				xmlWriter.WriteAttributeString("numberOfCrewMembersNeeded", this.numberOfCrewmenNeeded.ToString(CultureInfo.InvariantCulture));
			if (this.Rotation != this.refTask.Rotation)
				xmlWriter.WriteAttributeString("rotation", this.Rotation.TotalHours.ToString(CultureInfo.InvariantCulture));
			if (this.description != this.refTask.Description)
				xmlWriter.WriteElementString("description", this.description);
			xmlWriter.WriteStartElement("alternativePhases");
			//foreach (var alternativePhase in this.alternativePhases)
			//	alternativePhase.Save(xmlAlternativePhases);	//TODO: alternative phases
			xmlWriter.WriteEndElement();
			xmlWriter.WriteEndElement();
		}
		#endregion

		#region Simulation
		/// <summary>
		/// Cached information coming from Crewman.Qualifications. {Crewman, percentage}
		/// </summary>
		public readonly IDictionary<Crewman, byte> simulationCurrentQualifications;

		//public double timeTaskArrives;

		//public double timeTaskBegins;

		SimulationTime lastProcessTime;

		SimulationTime simulationTimeArrives = new SimulationTime(TimeUnit.Seconds, -1.0);

		/// <summary>
		/// Simulation time when this task instance has arrived (typically when changing state from "planned" to running).
		/// </summary>
		public SimulationTime SimulationTimeArrives
		{
			get { return this.simulationTimeArrives; }
			set
			{
				this.simulationTimeArrives = value;
				//if (this.simulationTimeLastCalculation < value)
					this.lastProcessTime = value;
			}
		}

		/*public SimulationTime SimulationTimeLastCalculation
		{
			get { return this.simulationTimeLastCalculation; }
			set { this.simulationTimeLastCalculation = value; }
		}*/

		SimulationTime remainingDuration = SimulationTime.Zero;

		/// <summary>
		/// Remaining man-hours before completion of the task.
		/// </summary>
		public SimulationTime RemainingDuration
		{
			get
			{
				//if (this.remainingDuration.NegativeOrZero) this.remainingDuration = SimulationTime.Zero;
				return this.remainingDuration;
			}
			internal set { this.remainingDuration = value; }
		}

		/// <summary>
		/// True if the task is completed, false otherwise.
		/// </summary>
		public bool Completed
		{
			get { return this.remainingDuration.NegativeOrZero; }
		}

		/// <summary>
		/// List of crewmen currently working on the task.
		/// </summary>
		public readonly List<Crewman> simulationCrewmenAssigned = new List<Crewman>();

		/// <summary>
		/// To call before starting a new occurence of the same simulation.
		/// </summary>
		public virtual void PrepareForNextOccurrence()
		{
			this.remainingDuration = this.Duration.XValue;
			this.lastProcessTime = this.simulationTimeArrives;
			//if (this.simulationCrewMembersAssigned == null) this.simulationCrewMembersAssigned = new List<CrewMember>();
			//else this.crewMembersAssigned.Clear();	//TODO: Find out if we want to clear the list at this point
		}

		/// <summary>
		/// To call when the task has been active until now, in order to update the statistics of the task (e.g. remaining duration).
		/// Does not call <see cref="Crewman.RefreshStatus"/> by default.
		/// </summary>
		/// <param name="currentTime">Current simulation time.</param>
		/// <param name="phase">Phase during which the process occurs.</param>
		/// <returns>A positive duration if the task was processed, <see cref="SimulationTime.Zero"/> otherwise.</returns>
		public virtual SimulationTime ProcessUntilNow(SimulationTime currentTime, Phase phase)
		{
			var previousProcessTime = this.lastProcessTime;
			this.lastProcessTime = currentTime;
			if (this.simulationCrewmenAssigned.Count >= this.numberOfCrewmenNeeded)
			{
				var duration = currentTime - previousProcessTime;
				if (duration.Positive)
				{
					this.remainingDuration -= duration;
					Debug.Assert((this.taskType == (int)StandardTaskType.InternalWait) || Allowed(phase), "A task must not run in phases where it is not allowed!");
					Debug.Assert(duration <= currentTime - phase.simulationTimeBegin, "A task cannot last longer than its phase!");
					return duration;
				}
			}
			return SimulationTime.Zero;
		}

		/// <summary>
		/// To call when the task has been waiting until now, in order to update the statistics of the task.
		/// </summary>
		/// <param name="currentTime">Current simulation time.</param>
		public virtual void SleepUntilNow(SimulationTime currentTime)
		{
			this.lastProcessTime = currentTime;
		}

		/// <summary>
		/// To call when the time since last update needs to be discarded.
		/// Used for instance when a task has to start a bit before than current time and be shortened accordingly.
		/// </summary>
		/// <param name="currentTime">Current simulation time.</param>
		public virtual void DiscardUntilNow(SimulationTime currentTime)
		{
			var duration = currentTime - this.lastProcessTime;
			if (duration.Positive) this.remainingDuration -= duration;
			this.lastProcessTime = currentTime;
		}

		public SimulationTime RemainingProcessingTime()
		{//TODO: Integrate simulationCrewMembersAssigned
			/*double speed = 1.0;
			double exclusivity = 1.0;
			return (speed <= 0.0) || (exclusivity <= 0) ? SimulationTime.MaxValue :
				new SimulationTime(TimeUnit.Seconds, (this.remainingDuration.TotalSeconds / speed) / exclusivity);*/
			return this.remainingDuration;
		}

		/// <summary>
		/// Check the different time constraints to tell when the task will next be allowed to be resumed.
		/// </summary>
		/// <param name="eventTime">A simulation time</param>
		/// <param name="allowCurrentTime">Gives the possibility to use the given simulation time</param>
		/// <returns>A simulation time in the relative future when the task is allowed to run</returns>
		public SimulationTime NextPossibleResume(SimulationTime eventTime, bool allowCurrentTime = true)
		{
			var workStart = eventTime.NextDayTime(this.DailyHourStart, allowCurrentTime);
			var workEnd = eventTime.NextDayTime(this.DailyHourEnd, allowCurrentTime);
			if ((workStart < workEnd) || (eventTime >= workEnd))
				eventTime = workStart;	//TimeWindow, next day
			else if (!allowCurrentTime) eventTime = eventTime.NextUp();
			if ((!this.onHolidays) && eventTime.IsSunday)
			{
				eventTime = eventTime.NextWeekTime(SimulationTime.OneDay, allowCurrentTime: false);	//Next monday
				workStart = eventTime.NextDayTime(this.DailyHourStart);
				workEnd = eventTime.NextDayTime(this.DailyHourEnd);
				if ((workStart < workEnd) || (eventTime >= workEnd))
					eventTime = workStart;	//TimeWindow, next day
			}
			return eventTime;
		}

		/// <summary>
		/// Tells if the task is allowed to run at this time of the day.
		/// </summary>
		/// <param name="eventTime">A date/time; only the time of the day will be used.</param>
		/// <returns>true if the task is allowed to run at this time of the day, false otherwise.</returns>
		public bool IsAllowedTime(SimulationTime eventTime)
		{
			return eventTime.InDayTimeInterval(this.DailyHourStart, this.DailyHourEnd) &&
				(this.onHolidays || (!eventTime.IsSunday) ||
					(!eventTime.NextDown().IsSunday));	//Case of Sunday at 00:00
		}
		#endregion
	}
}
