#define NO_STRINGS	//To use the same algorithms than systems that cannot use string. Faster anyway without strings.

using System;
using System.Collections.Generic;
using System.Text;

namespace SimManning
{
	/// <summary>
	/// Collection of global constants and static extensions.
	/// </summary>
	public static class SimManningCommon
	{
		/// <summary>
		/// Minimal value that can be generated by Math.Log taking a double as a parameter: -744.44007192138122
		/// </summary>
		/// <remarks>Called EXP_LIMIT_L in java.lang.StrictMath</remarks>
		internal static readonly double LogMinValue = Math.Log(Double.Epsilon);

		/// <summary>
		/// Get the number of digits in an integer number.
		/// For instance, 137 has 3 digits.
		/// </summary>
		/// <param name="code">The integer number to analyse</param>
		/// <returns>The number of digits in the given integer number.</returns>
		public static int NbDigits(this int code)
		{//Would be nicer as a property extension (e.g. number.NBDigits without parentheses) if C# supported it.
			return (int)(Math.Log10(code) + 1);
		}

		/// <summary>
		/// Return the first part of a "accounting-like" code (a positive integer in base 10).
		/// For instance the level 1 of code 357 is 3, its level 2 is 35, level 3 or more is 357.
		/// </summary>
		/// <param name="code">A code (ex: 357)</param>
		/// <param name="level">A code level (ex: 2). Default value is 1.</param>
		/// <returns>The subcode (ex: 35) of the provided code, at the provided level.</returns>
		public static int SubCode(this int code, int level = 1)
		{
			if (code <= 0 || level <= 0) return 0;
			#if (NO_STRINGS)
				var nbDigits = code.NbDigits();
				if (level >= nbDigits) return code;
				return (int)(code / Math.Pow(10, nbDigits - level));
			#else
				var sCode = code.ToString();
				return sCode.Length >= level ? Int32.Parse(sCode.Substring(0, level)) : code;
			#endif
		}

		/// <summary>
		/// Return a digit of a "accounting-like" code (a positive integer in base 10).
		/// For instance the digit level 2 of code 357 is 5, its level 3 is 7, level 4 or more is 0.
		/// </summary>
		/// <param name="code">A code (ex: 357)</param>
		/// <param name="digitLevel">A code digit level (ex: 2). Default value is 1.</param>
		/// <returns>The subcode digit (ex: 5) of the provided code, at the provided level.</returns>
		public static int SubCodeDigit(this int code, int digitLevel = 1)
		{
			if (code <= 0 || digitLevel <= 0) return 0;
			#if (NO_STRINGS)
				var nbDigits = code.NbDigits();
				if (digitLevel > nbDigits) return 0;
				var x = Math.Floor(code / Math.Pow(10, nbDigits - digitLevel)) / 10.0;
				return (int)((x - Math.Floor(x)) * 10.0);
			#else
				var sCode = code.ToString();
				return sCode.Length >= digitLevel ? byte.Parse(sCode[digitLevel - 1].ToString()) : (byte)0;
			#endif
		}

		/// <summary>
		/// Test if the first code is a sub-code of the second code (a positive integer in base 10).
		/// For instance, the code 357 is a sub-code (i.e. more specialised/precise), than the code 37 (more general).
		/// </summary>
		/// <param name="code">A code (ex: 357)</param>
		/// <param name="code2">Another code (ex: 35)</param>
		/// <returns><code>true</code> if <para>code</para> is a sub-code of <para>code2</para> (ex: 357 is a subcode of 35), <code>false</code> otherwise (ex: 357 is not a subcode of 400, or of 3571)</returns>
		public static bool IsSubCodeOf(this int code, int code2)
		{
			if (code <= 0 || code2 <= 0) return false;
			#if (NO_STRINGS)
				var nbDigits1 = code.NbDigits();
				var nbDigits2 = code2.NbDigits();
				if (nbDigits2 > nbDigits1) return false;
				return code2 == (int)(code / Math.Pow(10, nbDigits1 - nbDigits2));
			#else
				return code.ToString().StartsWith(code2.ToString());
			#endif
		}

		/// <summary>
		/// Test if the first code is a sub-code of the second code (a positive integer in base 10).
		/// For instance, the code 357 is a sub-code (i.e. more specialised/precise), than the code 37 (more general).
		/// </summary>
		/// <param name="code">A special code (ex: 357)</param>
		/// <param name="code2">A special code (ex: Task.SpecialTaskType.Undefined)</param>
		/// <returns><code>true</code> if <para>code</para> is a sub-code of <para>code2</para> (ex: 357 is a subcode of 35), <code>false</code> otherwise (ex: 357 is not a subcode of 400, or of 3571)</returns>
		public static bool IsSubCodeOf(this int code, StandardTaskType code2)
		{
			return code.IsSubCodeOf((int)code2);
		}

		/// <summary>
		/// Clear an array by setting all its values to the default value associated to its type (e.g. 0 for an Int32).
		/// </summary>
		/// <typeparam name="T">The type of the cells of the array</typeparam>
		/// <param name="array">An array to clear</param>
		public static void Clear<T>(this T[] array)
		{
			if (array == null) return;
			for (var i = array.Length - 1; i >= 0; i--)
				array[i] = default(T);
		}

		#region .NET Core: Manual implementations of routines existing in .NET 4.0 but not in .NET 4.5 Core (Metro) and Silverlight.
		/// <summary>
		/// Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire List.
		/// </summary>
		/// <typeparam name="T">The type of item contained in the list.</typeparam>
		/// <param name="list">The list to search.</param>
		/// <param name="match">The Predicate delegate that defines the conditions of the element to search for</param>
		/// <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.</returns>
		public static int FindIndex<T>(this IList<T> list, Predicate<T> match)
		{
			var maxI = list.Count;
			for (var i = 0; i < maxI; i++)
				if (match(list[i]))
					return i;
			return -1;
		}

		/// <summary>
		/// Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List.
		/// </summary>
		/// <typeparam name="T">The type of item contained in the list.</typeparam>
		/// <param name="list">The list to search.</param>
		/// <param name="match">The Predicate delegate that defines the conditions of the element to search for</param>
		/// <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.</returns>
		public static int FindLastIndex<T>(this IList<T> list, Predicate<T> match)
		{
			for (var i = list.Count - 1; i >= 0; i--)
				if (match(list[i]))
					return i;
			return -1;
		}
		#endregion

		#region Fake PLinq for Silverlight
		/*//Allow in Silverlight the syntax used to enable parallelization of a query.
		//However, in Silverlight, there is no parallelization and thus no gain of using this function.
		public static IList<TSource> AsParallel<TSource>(this IList<TSource> source)
		{
			return source;
		}

		public static Dictionary<TKey, TValue>.ValueCollection AsParallel<TKey, TValue>(this Dictionary<TKey, TValue>.ValueCollection source)
		{
			return source;
		}*/
		#endregion
	}
}
